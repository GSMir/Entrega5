---
title: "Entrega 5"
author: "Ángel García, Arnau Piferrer  y Guillem Serra"
format: html
editor: visual
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

```{r, message = FALSE, warning=FALSE}
library(tidyverse)
library(factoextra)
library(ggbiplot)
library(ggplot2)
```

**Considera los datos *"europa.dat"* que están disponibles en Aula Digital. Los datos corresponden a los porcentajes de población empleados en diferentes actividades económicas en Europa para el año 1979. Las variables consideradas son:**

**Agricultura, Minas, Fábricas, Suministro Eléctrico, Construcción, Industrias de Servicio, Finanzas, Servicios Sociales y Personales y, Transporte y Comunicaciones.**

**Utiliza el método de componentes principales para reducir el número de variables, y tratar de determinar grupos de países con comportamientos semejantes en la distribución de su fuerza de trabajo. En este caso, usa la matriz de covarianza para el cálculo de las componentes principales, ya que todos los datos están medidos en la misma escala (porcentaje de la población) y por las caractersticas de los datos, no parece una buena idea considerarlos todos de igual manera.**

En primer lugar procedemos a cargar nuestros datos:

```{r}
europa = read.table("europa.dat")
head(europa, 26)
```

Creo que lo anterior no es correcto. Si os fijáis en el enunciado pone que se tiene que usar el PCA de covarianzas, no el de correlaciones. Con esta función "princomp()" puedes especificar si quieres usar
la matriz de correlaciones (corr = TRUE) o la matriz de covarianzas (cor=FALSE) y los resultados en el caso de usar la matriz de covarianzas (LA QUE PIDE EL ENUNCIADO) coinciden con los de la función que hemos intentado usar antes pero para "scale = FALSE".

Propongo proceder así, en vernos podemos discutirlo más en detalle:


```{r}
europa.acp_2=princomp(europa[,1:9], cor = FALSE) 
# Implementamos el modelo ACP
# Al tomar cor = FALSE estamos usando la matriz de covarianzas
europa.acp_2
```

1) Hacemos un summary y vemos cuáles son los valores propios, la varianza explicada por cada componente y la varianza acumulada.

El problema (o no, no lo sé del todo) con la variabilidad acumulada es que prácticamente toda la acumula la primera componente principal y que con únicamente extenderla a 2 componentes principales ya abarcamos másdel 90% de la variabilidad, lo que en teoría debería de ser bueno.

Lo que pasa es que creo que hay ciertos outliers que hacen que se vayan de madre los números y que realmente deberíamos quizás de excluir esos países y hacer el análisis sin tenerlos en cuenta (Turquía, Yugoslavia, los vimos en el análisis incorrecto que intentamos hacer al principio, de eso sí que podemos fiarnos).

```{r}
summary(europa.acp_2)
```

Podemos complementar de forma más visual la aportación de variabilidad que refleja cada una de las componentes con un gráfico. Esto debería de sugerirnos cuántos componentes retener.

```{r}
fviz_eig(europa.acp_2, addlabels = TRUE, ylim=c(0,100)) + ggtitle("Peso de las direcciones principales")
```


3) Examinar las cargas de los componentes principales para entender cómo cada variable original contribuye a cada componente. Esto nos debería de ser de ayuda para interpretar el significado de los componentes.

```{r}
loadings(europa.acp_2) 
# Examinamos los pesos de cada variable en cada componente principal
# El problema es que MIN, ENE, CON no están representadas en ninguna de las primeras.
```


4) Hacer un biplot para visualizar simultáneamente las cargas y los scores de los componentes principales. Básicamente hacer el gráfico redondito con el círculo.

Esto debería de proporcionar una visión clara de cómo se relacionan las variables y los países en el espacio de las CP1 y CP2


```{r}
europa %<>% mutate(Pais=row.names(.)) %>% relocate(Pais,.before = Agr)
rownames(europa) = NULL
```



```{r}
ggbiplot(pcobj=europa.acp_2,
         choices = c(1,2), #Indicamos la cantidad de componentes principales que queremos
         obs.scale = 1,var.scale = 1,
         labels = europa[,1],
         varname.size = 5,
         circle = TRUE
         )+labs(title = "Proyección en 2 dimensiones")

```

Análisis de los Scores: Revisa los scores de los componentes principales para ver cómo cada observación (país) se posiciona en los componentes principales seleccionados. Esto es útil para identificar patrones o agrupaciones.

```{r}
scores <- predict(europa.acp_2)
head(scores)
```


```{r}

ggbiplot(europa.acp_2, choices = c(1, 2), labels = europa[,1]) +
  ggtitle("Biplot de PCA") +
  theme_minimal()

```

PROPUESTA: eliminar yugoslavia y turquía y ver qué pasa

```{r}
europa = read.table("europa.dat")


# Suponiendo que tu dataframe se llama 'europa'
europa_sin_tur_yug <- europa[-c(12, 18, 26), ] # Exluimos Yugoslavia y Turquía


# Ahora realizamos el PCA en el conjunto de datos modificado, sin Turquía y Yugoslavia
europa.acp_sin_tur_yug <- princomp(europa_sin_tur_yug[, 1:9], cor = FALSE)
europa.acp_sin_tur_yug


```

```{r}
europa_sin_tur_yug %<>% mutate(Pais=row.names(.)) %>% relocate(Pais,.before = Agr)
rownames(europa) = NULL


europa_sin_tur_yug
```



```{r}
ggbiplot(europa.acp_sin_tur_yug, choices = c(1, 2), labels = europa_sin_tur_yug[,1]) +
  ggtitle("Biplot de PCA") +
  theme_minimal()

```

```{r}
fviz_eig(europa.acp_sin_tur_yug, addlabels = TRUE, ylim=c(0,100)) + ggtitle("Peso de las direcciones principales")

```


```{r}
loadings(europa.acp_sin_tur_yug) 
# Examinamos los pesos de cada variable en cada componente principal
# El problema es que MIN, ENE, CON no están representadas en ninguna de las primeras.
```

```{r}
#Mmedias = europa %>%
# + summarise_if(is.numeric, mean, na.rm = TRUE)
```

